1.什么是竞态条件（Race Condition）？
    竞态条件是指多个线程对共享资源（如变量、内存等）同时进行操作时，由于线程的执行顺序不可预测，导致程序的行为和结果不符合预期。

    在"11文件"的例子中，money += 1 这个操作是一个 非原子操作，它实际包含了以下几个步骤：

        1.读取当前的 money 值。
        2.将 money 增加 1。
        3.将更新后的值写回 money。

    这看起来是一个简单的操作，但问题出在多个线程同时执行这个操作时，它们之间的执行是交替进行的，
    无法保证顺序。当两个线程同时执行 money += 1 时，可能发生以下情况：

        竞态条件示例：
        假设 money 初始值为 0，线程 t1 和 t2 依次执行 money += 1 操作。

        1.线程 t1 执行：
            线程 t1 读取 money 的值（此时是 0）。
            线程 t1 将 money 增加 1，得到 1,并且等待 CPU 的时间片继续执行。

        2.线程 t2 执行：
            在 t1 还没有将 money 写回内存时，线程 t2 获得了执行机会。
            线程 t2 读取 money 的值（此时也是 0，因为 t1 还没写回）。
            线程 t2 将 money 增加 1，得到 1,并准备写回内存。

        3.线程 t1 继续执行：
            线程 t1 再次获得执行机会，它将 money 的值写回内存（此时它的值是 1）。

        4.线程 t2 继续执行：
            线程 t2 也获得执行机会，它将 money 的值写回内存（此时它的值也是 1）。
        最终，money 的值是 1，而不是 2，因为 t1 和 t2 都读取了 money 为 0，然后分别增加 1，导致它们覆盖了对方的修改。这个现象就是 竞态条件。

        线程调度：由于【线程的调度是由操作系统控制的，它的执行顺序不可预见】。在上面的例子中，线程 t1 和 t2 会交替执行，
        而每次它们访问 money 变量时并没有同步控制，因此会发生数据冲突。

2.GIL 的作用与限制
    Python 的 GIL（全局解释器锁）在某些情况下会影响线程的并行执行，它的主要作用是 防止多个线程同时执行 Python 字节码，
    避免数据在多个线程之间产生冲突和不一致。

    GIL 在“11文件”中的例子中的作用：
        在 CPython（Python 的标准实现）中，GIL 确保同一时刻只有一个线程在执行 Python 代码。这意味着即使你有多个线程，
        GIL 会使得线程 轮流执行 Python 字节码，而不是真正的并行执行。但是 GIL 只是阻止多个线程并发执行 Python 字节码，
        它并不完全解决 多线程访问共享数据时的竞态条件问题。即使 GIL 保证了一个时刻只有一个线程在执行 Python 代码，
        当多个线程试图同时修改同一个变量时，仍然会出现竞态条件。

3.为什么 GIL 无法解决这个问题？
    ***【GIL 控制的是线程执行的顺序，它不处理线程间共享数据的安全性。】***
    即使只有一个线程可以在任何时刻执行 Python 代码，但 多个线程可以在同一时刻访问和修改共享变量，导致数据不一致。
    GIL 并不会保护共享数据，因此我们依然需要使用锁（threading.Lock）来确保每次只有一个线程能够修改 money。